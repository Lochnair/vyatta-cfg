#include <stdio.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <getopt.h>
#include <iostream>
#include <sstream>
#include <fstream>
#include <netinet/ether.h>
#include <arpa/inet.h>
#include <cmath>
#include <errno.h>

#include <boost/filesystem.hpp>
#include <boost/algorithm/string.hpp>

#include "ubnt_interface.hpp"
#include "../lib/vyatta_interface.hpp"
#include "../lib/vyatta_config.hpp"

using namespace std;

//global variables
static string if_name;
static string if_path;
static string cfg_root_path;
static string template_path;
static string vif_name;
static string mac;
static string dhcp_req;
static string dhcp_daemon = "/sbin/dhclient";
static string type;

static bool is_dhcp_cmd;
static bool is_mac_cmd;
static bool is_addr_commit_cmd;
static bool is_check_cmd;
static bool is_check_non_switched_cmd;
static bool is_show_cmd;
static bool is_check_bw;
static bool restore_ipv6_cmd;
static bool has_dhcp_enabled;
static bool show_path;

typedef vyatta::Interface InterfaceT;

/*
 * helpers
 */
static bool touch(const string& path)
{
  int fd = open(path.c_str(), O_WRONLY|O_CREAT,
                S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);
  if (fd == -1) {
    if (EEXIST != errno) {
      return false;
    }
    return true;
  }
  close(fd);
  return true;
}

static int _system(const string& cmd, const string& msg, const bool die = false)
{
  int ret = system(cmd.c_str());
  if (-1 == ret && ECHILD == errno) {
      // sigchld_handler took the signal, no way to detect the real return code. Lets assume it was ok
      ret = 0;
  }
  if (ret) {
    int err = errno;
    cerr << msg << " (";
    if (-1 == ret) {
      cerr << strerror(err);
    } else {
      cerr << WEXITSTATUS(ret);
    }
    cerr << ")" << endl;
    if (die) {
      exit(1);
    }
  }
  return ret;
}

/*
 * lib/Vyatta/Misc.pm
 */
/*
 * check if interface is configured to get an IP address using dhcp
 */
static bool is_dhcp_enabled(InterfaceT& intf)
{
  if (!intf.get()) {
    return false;
  }

  vyatta::Config config(intf.path());
  // the "effective" observers can be used both inside and outside
  // config sessions.
  vector<string> addrs;
  if (config.returnEffectiveValues("address", addrs)) {
    for (size_t i = 0; i < addrs.size(); i ++) {
      if (addrs[i] == "dhcp") {
        return true;
      }
    }
  }
  return false;
}

/*
 * return dhclient related files for interface
 */
static void generate_dhclient_intf_files(string name, string& intf_config_file,
                                         string& intf_process_id_file,
                                         string& intf_leases_file)
{
  string dhclient_tmp("/var/run/dhclient_");
  boost::replace_all(name, ".", "_");
  intf_config_file = dhclient_tmp + name + ".conf";
  intf_process_id_file = dhclient_tmp + name + ".pid";
  intf_leases_file = dhclient_tmp + name + ".leases";
}

/*
 * get list of interfaces on the system via sysfs
 * skip dot files (and any interfaces name .xxx)
 *  and bond_masters file used by bonding
 *  and wireless control interfaces
 *  checks if particular interface is among the listed
 */
static bool checkInterfaceExists(const string& name)
{
  vector<string> intfs;
  InterfaceT::listSystemInterfaces(intfs);
  for (size_t i = 0; i < intfs.size(); i ++) {
    if (intfs[i] == name) {
      return true;
    }
  }
  return false;
}

/*
 * get list of interfaces on the system via sysfs
 * skip dot files (and any interfaces name .xxx)
 *  and bond_masters file used by bonding
 *  and wireless control interfaces
 */
static void getInterfaces(vector<string>& intfs)
{
  InterfaceT::listSystemInterfaces(intfs);
}

/*
 * scripts/vyatta-interfaces.pl
 */
static void dhcp_write_file(const string& path, const string& data)
{
  int fd = open(path.c_str(), O_WRONLY|O_CREAT|O_TRUNC,
                S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);
  if (fd == -1) {
    cerr << "Couldn't open " << path << " (" << strerror(errno) << ")" << endl;
    exit(1);
  }

  ssize_t ret = write(fd, data.c_str(), data.size());
  if (ret != (ssize_t)data.size()) {
    cerr << "Write error " << path << endl;
  }
  close(fd);
}

static void dhcp_conf_header(string& output)
{
  time_t now = time(0);
  tm *gmtm = gmtime(&now);
  char* dt = asctime(gmtm);
  output = string("#\n# autogenerated by vyatta-interfaces.pl on UTC ")
    + string(dt) + string("#\n");
}

static bool get_hostname(string& hostname)
{
  vyatta::Config config("system");
  return config.returnValue("host-name", hostname);
}

static bool is_domain_name_set(string& domain_name)
{
  vyatta::Config config("system");
  return config.returnValue("domain-name", domain_name);
}

static string get_mtu(InterfaceT& intf)
{
  return intf.mtu();
}

static string replace_quot(const string& line)
{
  int count = 0;
  string sub("&quot;");
  for (size_t offset = line.find(sub); offset != string::npos;
        offset = line.find(sub, offset + sub.length())) {
    count ++;
  }
  if (count % 2) {
    cerr << "Error: unbalanced quotes " << count << " [" << line << "]\n" << endl;
    exit(1);
  }

  string rl(line);
  boost::replace_all(rl, "&quot;", "\"");
  return rl;
}

/*
 * adds new options to output string. output can already contain some data
 */
static void get_global_options(InterfaceT& intf, string& output)
{
  string path = intf.path() + " dhcp-options";
  vyatta::Config config(path);

  vector<string> options;
  if (config.returnValues("global-option", options)) {
    for (size_t i = 0 ; i < options.size(); i ++) {
      output += replace_quot(options[i]) + "\n";
    }
  }
}

static void get_client_options(InterfaceT& intf, string& output)
{
  string path = intf.path() + " dhcp-options";
  vyatta::Config config(path);

  vector<string> options;
  if (config.returnValues("client-option", options)) {
    for (size_t i = 0 ; i < options.size(); i ++) {
      output += "\t" + replace_quot(options[i]) + "\n";
    }
  }
}

static void dhcp_update_config(const string& conf_file, InterfaceT& intf)
{
  string output;
  dhcp_conf_header(output);
  output += "option rfc3442-classless-static-routes code 121 = array of unsigned integer 8;\n";
  get_global_options(intf, output);
  output += "\n";

  output += "interface \"" + intf.name() + "\" {\n";
  string hostname;
  if (get_hostname(hostname) && !hostname.empty()) {
    output += "\tsend host-name \"" + hostname + "\";\n";
  }
  output += "\trequest subnet-mask, broadcast-address, routers, domain-name-servers";
  string domainname;
  if (!is_domain_name_set(domainname) || domainname.empty()) {
    output += ", domain-name";
  }

  string mtu = get_mtu(intf);
  if (mtu.empty()) {
    output += ", interface-mtu";
  }
  output += ";\n";

  get_client_options(intf, output);
  output += "}\n\n";

  dhcp_write_file(conf_file, output);
}

/*
 * Is interface disabled in configuration (only valid in config mode)
 */
static bool is_intf_disabled(InterfaceT& intf)
{
  vyatta::Config config(intf.path());
  return config.exists("disable");
}

static void run_dhclient(InterfaceT& intf, const bool op = false)
{
  string intf_config_file, intf_process_id_file, intf_leases_file;
  generate_dhclient_intf_files(intf.name(), intf_config_file,
                               intf_process_id_file, intf_leases_file);
  if (!op) {
    // perform config mode actions if not called from op-mode
    dhcp_update_config(intf_config_file, intf);
    if (is_intf_disabled(intf)) {
      return;
    }
  }

  string cmd;
  if (boost::filesystem::exists(intf_process_id_file)) {
    string str;
    ifstream ifs(intf_process_id_file.c_str());
    if (getline(ifs, str)) {
      boost::trim(str);
      if (!str.empty()) {
        cmd = "/bin/kill " + str + " 2> /dev/null;";
        cmd += "/bin/rm -f " + intf_process_id_file + " 2> /dev/null;";
      }
    }
  }
  cmd += dhcp_daemon +
    " -q -nw -cf " + intf_config_file +
    " -pf " + intf_process_id_file +
    " -lf " + intf_leases_file + " " +
    intf.name() + " 2> /dev/null";
  _system(cmd, "start dhcp daemon failed");
}

static void stop_dhclient(InterfaceT& intf, const bool op = false)
{
  // perform config mode actions if not called from op-mode
  if (!op && is_intf_disabled(intf)) {
    return;
  }

  string intf_config_file, intf_process_id_file, intf_leases_file;
  generate_dhclient_intf_files(intf.name(), intf_config_file,
                               intf_process_id_file, intf_leases_file);

  string release_cmd = dhcp_daemon +
    " -q -cf " + intf_config_file +
    " -pf " + intf_process_id_file +
    " -lf " + intf_leases_file +
    " -r " + intf.name() + " 2> /dev/null;";
  release_cmd += "/bin/rm -f " + intf_process_id_file + " 2> /dev/null";
  _system(release_cmd, "stop dhcp daemon failed");
}

static bool is_valid_mac(const string& mac, string& msg)
{
  if (mac.size() > ETH_ALEN*2 + (ETH_ALEN - 1)) {
    msg = "Error: Argument too long";
    return false;
  }

  struct ether_addr* ether = ether_aton(mac.c_str());
  if (ether == NULL) {
    msg = "Error: Argument contains invalid characters";
    return false;
  }

  bool invalid = true;
  for (int i = 0; i < ETH_ALEN; i ++) {
    if (ether->ether_addr_octet[i]) {
      invalid = false;
      break;
    }
  }
  if (invalid) {
    msg = "Error: zero is not a valid address";
    return false;
  }

  if (ether->ether_addr_octet[0] & 1) {
    msg = "Error: a multicast address";
    return false;
  }

  return true;
}

static bool update_mac(const string& mac, const string& name)
{
  InterfaceT intf(name);
  if (!intf.get()) {
    cerr << "Unknown interface name/type: " << name << endl;
    exit(1);
  }

  string msg;
  if (!is_valid_mac(mac, msg)) {
    cerr << msg << ": " << mac << endl;
    exit(1);
  }

  string cmd;
  if (intf.up()) {
    cmd = "/sbin/ip link set " + name + " down";
    msg = "Could not " + cmd;
    _system(cmd, msg, true);
    cmd = "/sbin/ip link set " + name + " address " + mac;
    msg = "Could not " + cmd;
    _system(cmd, msg, true);
    cmd = "/sbin/ip link set " + name + " up";
    msg = "Could not " + cmd;
    _system(cmd, msg, true);
  } else {
    cmd = "/sbin/ip link set " + name + " address " + mac;
    msg = "Could not " + cmd;
    _system(cmd, msg, true);
  }
  return true;
}

/*
 * Validate the set of address values configured on an interface at commit
 * Check that full set of address values are consistent.
 *  1. Interface may not be part of bridge or bonding group
 *  2. Can not have both DHCP and a static IPv4 address.
 */
static bool is_valid_addr_commit(const string& name, const vector<string>& addrs)
{
  InterfaceT intf(name);
  if (!intf.get()) {
    cerr << "Unknown interface name/type: " << name << endl;
    exit(1);
  }

  vyatta::Config config(intf.path());

  string master;
  if (config.returnValue("bridge-group bridge", master) && !master.empty()) {
    cerr
      << "Can't configure address on interface that is port of bridge."
      << endl;
    exit(1);
  }
  if (config.returnValue("bond-group", master) && !master.empty()) {
    cerr
      << "Can't configure address on interface that is slaved to bonding interface."
      << endl;
    exit(1);
  }

  // Map of all the ip addresses
  //??? my %ipaddr_hash = map { $_ => 1 } getIP();

  unsigned char buf[sizeof(struct in6_addr)];
  bool dhcp = false, static_v4 = false;
  for (size_t i = 0; i < addrs.size(); i ++) {
    if (addrs[i] == "dhcpv6") {
      continue;
    } else if (addrs[i] == "dhcp") {
      dhcp = true;
    } else if (!InterfaceT::is_uniq_address(addrs[i])) {
      cerr << "Error: duplicate address" << endl;
      exit(1);
    } else if (inet_pton(AF_INET, addrs[i].substr(0, addrs[i].find('/')).c_str(), buf) == 1) {
      static_v4 = true;
    }
    if (static_v4 && dhcp) {
      cerr << "Can't configure static IPv4 address and DHCP on the same interface." << endl;
      exit(1);
    }
  }

  return true;
}

/*
 * Is interface currently in admin down state?
 */
static bool
is_intf_down(InterfaceT& intf)
{
  if (intf.get()) {
    return !intf.up();
  }
  return true;
}

static void dhcp(const string& request, const string& name)
{
  InterfaceT intf(name);
  if (!intf.get()) {
    cerr << "Unknown interface name/type: " << name << endl;
    exit(1);
  }

  if (!(request == "start"   ||
        request == "restart" ||
        is_dhcp_enabled(intf))) {
    cerr << name << " is not using DHCP to get an IP address" << endl;
    exit(1);
  }
  if (request != "stop" && is_intf_down(intf)) {
    cerr << name << " is disabled." << endl;
    exit(1);
  }

  string tmp_dhclient_dir("/var/run/vyatta/dhclient/");
  if (request == "release") {
    string release_file = tmp_dhclient_dir + "dhclient_release_" + name;
    if (boost::filesystem::exists(release_file)) {
      cerr << "IP address for " << name
           << " has already been released." << endl;
      exit(1);
    }
    cout  << "Releasing DHCP lease on " << name << " ..." << endl;
    stop_dhclient(intf, true);
    if (!boost::filesystem::exists(tmp_dhclient_dir)) {
      if (!boost::filesystem::create_directories(tmp_dhclient_dir)) { // permissions???
        cerr << "Failed to release dhcp on " << name << endl;
        exit(1);
      }
    }
    if (!touch(release_file)) {
      cerr << "Failed to release " << name << endl;
      exit(1);
    }
  } else if (request == "renew") {
    string release_file = tmp_dhclient_dir + "dhclient_release_" + name;
    cout  << "Renewing DHCP lease on " << name << " ..." << endl;
    run_dhclient(intf, true);
    unlink(release_file.c_str());
  } else if (request == "start" || request == "start_op") {
    cout  << "Starting DHCP client on " << name << " ..." << endl;
    string file = "/var/run/" + name;
    if (!touch(file)) {
      cerr << "Failed to start dhcp on " << name << endl;
      exit(1);
    }
    run_dhclient(intf, request == "start_op");
  } else if (request == "stop" || request == "stop_op") {
    cout  << "Stopping DHCP client on " << name << " ..." << endl;
    stop_dhclient(intf, request == "stop_op");
    string file = "/var/run/dhclient_" + name + "_lease";
    unlink(file.c_str());
    file = "/var/run/" + name;
    unlink(file.c_str());
    file = "/var/run/vyatta/dhclient/dhclient_release_" + name;
    unlink(file.c_str());
    string ifname = name;
    boost::replace_all(ifname, ".", "_");
    file = "/var/run/dhclient_" + ifname + ".conf";
    unlink(file.c_str());
  } else if (request == "restart") {
    cout  << "Restarting DHCP on " << name << " ..." << endl;
    run_dhclient(intf);
  } else {
    cerr << "Unknown DHCP request: " << request << endl;
    exit(1);
  }
}

static bool is_valid_name(const string& name, const string& type)
{
  if (name.empty()) {
    cerr << "Missing --dev argument\n" << endl;
    exit(1);
  }

  InterfaceT intf(name);
  if (!intf.get()) {
    cerr << name << " does not match any known interface name type" << endl;
    exit(1);
  }

  if (!intf.vif().empty()) {
    cerr << name << " is the name of VIF interface" << endl;
    cerr << "Need to use \"interface " << intf.dev()
         << " vif " << intf.vif() << "\"" << endl;
    exit(1);
  }

  if (type != "all" && type != intf.type()) {
    cerr << name << " is a " << intf.type()
         << "  interface not an " << type << " interface" << endl;
    exit(1);
  }

  if (!checkInterfaceExists(name)) {
    cerr << type << " interface " << name
         << " does not exist on system" << endl;
    exit(1);
  }

  return true;
}

/*
 * generate one line with all known interfaces (for allowed)
 */
static void show_interfaces(const string& type, const string& vif_name)
{
  int count = 0;
  vector<string> intfs;

  getInterfaces(intfs);

  for (size_t i = 0; i < intfs.size(); i ++) {
    InterfaceT intf(intfs[i]);
    if (!intf.get()) {
      // skip unknown types
      continue;
    }

    //next if $skip_interface{$name};
    if (type != "all" && type != intf.type()) {
      continue;
    }

    if (!vif_name.empty()) {
      if (intf.vif().empty()) {
        continue;
      }
      if (vif_name == intf.dev()) {
        if (count ++) {
          cout << " ";
        }
        cout << intf.vif();
      }
    } else {
      if (intf.vif().empty() || type == "all") {
        if (count ++) {
          cout << " ";
        }
        cout << intfs[i];
      }
    }
  }
  cout << endl;
}

static bool check_non_switched(const string& name)
{
  vyatta::Config config("interfaces switch switch0 switch-port");
  vector<string> intfs;
  //bool a = config.returnValues("interface", intfs);
  config.listNodes("interface", intfs);

  for (size_t i = 0; i < intfs.size(); i ++) {
    if (name == intfs[i]) {
      return false;
    }
  }
  return true;
}

static double get_num(string bw, string& suffix)
{
  char *endptr = 0;

  if (bw.empty()) {
    return -1;
  }
  boost::trim(bw);

  errno = 0;
  double num = strtod(bw.c_str(), &endptr);
  /* Check for various possible errors */
  if ((errno == ERANGE && (num == HUGE_VALF || num == HUGE_VALL))
      || (errno != 0 && num == 0)) {
    return -1;
  }
  if (endptr == bw.c_str()) {
    return -1;
  }
  if (endptr && *endptr != '\0') {
    suffix = endptr;
  }
  return num;
}

static long long normalize_bw(const string& bw)
{
  string suffix;

  long long bwv = get_num(bw, suffix);
  if (bwv < 0) {
    return -1;
  }
  if (!suffix.empty()) {
    if (suffix == "k") {
      bwv *= 1;
    } else if (suffix == "m") {
      bwv *= 1000;
    } else if (suffix == "g") {
      bwv *= 1000000;
    } else {
      return -1;
    }
  }
  return bwv;
}

static void check_bw(const string& bw)
{
  long long bwv = normalize_bw(bw);
  if (bwv < 0 || bwv > 10000000) {
    cerr << "Invalid bandwidth value " << bw << endl;
    exit(1);
  }
}

static void restore_ipv6_addr(const string& name,
                              const vector<string>& addrs)
{
  unsigned char buf[sizeof(struct in6_addr)];

  for (size_t i = 0; i < addrs.size(); i ++) {
    if (addrs[i] == "dhcp" || addrs[i] == "dhcpv6") {
      continue;
    }

    size_t pos = addrs[i].find('/');
    if (pos == string::npos) {
      continue;
    }
    string suffix, mask = addrs[i].substr(pos + 1);
    long long mask_len = get_num(mask, suffix);
    if (mask_len < 0 || mask_len > 128 || !suffix.empty()) {
      continue;
    }

    string addr = addrs[i].substr(0, pos);
    if (inet_pton(AF_INET6, addr.c_str(), buf) != 1) {
      continue;
    }
    /*
     * If running interactively then 'ip' will print NETLINK answer.
     * The error is unlikely. We want to continue as restoring other
     * addresses might succeed.
     */
    _system("sudo /sbin/ip -6 addr add " + addrs[i] + " dev " + name,
            "set ipv6 address failed");
  }
}

/*
 * On Linux the kernel removes IPv6 addresses from the interfaces when
 * cable is disconnected or the interface is disabled with 'ip link set eth0 down'
 * or similarly by using NETLINK dirrectly. We restore the addresses for
 * administrative purposes.
 */
static void restore_ipv6(const string& name)
{
  if (name.empty()) {
    cerr << "Missing --dev argument\n" << endl;
    exit(1);
  }

  InterfaceT intf(name);
  if (!intf.get()) {
    cerr << name << " does not match any known interface name type" << endl;
    exit(1);
  }

  vector<string> addrs;
  vyatta::Config config(intf.path());
  config.returnOrigValues("address", addrs);

  if (!intf.vif().empty()) {
    /*
     * Handle eth1.4 (eth1, VLAN 4) case:
     * "set interfaces ethernet eth1 vif 4 address".
     */
    restore_ipv6_addr(name, addrs);
  } else {
    /*
     * Handle eth1 (eth1, no VLAN) case:
     * "set interfaces ethernet eth1 address...".
     */

    /*
     * Handle lo case - ::1/128 is added by kernel during boot-up,
     * make sure it stays on the loopback interface.
     */
    if (name == "lo") {
      addrs.push_back("::1/128");
    }
    restore_ipv6_addr(name, addrs);

    if (config.existsOrig("vif")) {
      /*
       * Handle base interface's VLANs, for example:
       * - base interface eth1;
       * - eth1 VLAN 4 interface eth1.4;
       * - eth1 is disabled.
       *
       * In this case the IPv6 addresses must be restored
       * also for eth1.4.
       */
      vector<string> vifs;
      config.listOrigNodes("vif", vifs);
      for (size_t i = 0; i < vifs.size(); i ++) {
        addrs.clear();
        if (config.returnOrigValues("vif " + vifs[i] + " address", addrs)) {
          restore_ipv6_addr(name + "." + vifs[i], addrs);
        }
      }
    }
  }
}

static void show_cfg_path(const string& name)
{
  if (name.empty()) {
    cerr << "Missing --dev argument\n" << endl;
    exit(1);
  }

  InterfaceT intf(name);
  if (!intf.get()) {
    cerr << name << " does not match any known interface name type" << endl;
    exit(1);
  }

  cout << intf.path() << endl;
}

/*
 * Specifying the expected options
 * The two options l and b expect numbers as argument
 */
enum {
  IF_NAME = 1000,
  IF_PATH,
  CFG_PATH,
  TEMPL_PATH,
  DEV,
  VIF_NAME,
  DHCP_CMD,
  SET_MAC_CMD,
  ADDR_COMMIT_CMD,
  CHECK_CMD,
  CHECK_NON_SWITCHED_CMD,
  SHOW_CMD,
  CHECK_BW,
  RESTORE_IPV6,
  HAS_DHCP_ENABLED,
  SHOW_CFG_PATH
};

static struct option long_options[] = {
  {"if-name",           required_argument,  0,          IF_NAME }, // i.e. eth0.42
  {"dev",               required_argument,  0,          DEV }, // i.e. eth0.42
  {"if-path",           required_argument,  0,          IF_PATH }, // i.e. interfaces ethernet var vif
  {"cfg-root-path",     required_argument,  0,          CFG_PATH }, // i.e. interfaces ethernet eth0 vif 42
  {"template-path",     required_argument,  0,          TEMPL_PATH }, // i.e. interfaces ethernet var vif var
  {"dhcp",              required_argument,  0,          DHCP_CMD },
  {"set-mac",           required_argument,  0,          SET_MAC_CMD },
  {"valid-addr-commit", required_argument,  0,          ADDR_COMMIT_CMD },
  {"check",             required_argument,  0,          CHECK_CMD },
  {"check-non-switched",no_argument,        0,          CHECK_NON_SWITCHED_CMD },
  {"show",              required_argument,  0,          SHOW_CMD },
  {"vif",               required_argument,  0,          VIF_NAME },
  {"check-bw",          required_argument,  0,          CHECK_BW },
  {"restore-ipv6",      no_argument,        0,          RESTORE_IPV6 },
  {"is_dhcp_enabled",   no_argument,        0,          HAS_DHCP_ENABLED },
  {"show-cfg-path",     no_argument,        0,          SHOW_CFG_PATH }, // i.e. interfaces ethernet eth0 vif 42
  {0,                   0,                  0,          0 }
};

/**
 * @brief The main function ubnt-interface application.
 * @param[in] argc Arguments count.
 * @param[in] argv Arguments array.
 * @return Exit status of the application.
 */
int main(int argc, char **argv)
{
  int  opt = 0, index;
  vector<string> addrs;

  if (argc < 2) {
    cerr << "Error: missing command" << endl;
    exit(1);
  }

  while ((opt = getopt_long_only(argc, argv, "",
                                 long_options, &index)) != -1) {
    switch (opt) {
      case DEV:
      case IF_NAME:
        if (optarg) {
          if_name = optarg;
        }
        break;
      case IF_PATH:
        if (optarg) {
          if_path = optarg;
        }
        break;
      case CFG_PATH:
        if (optarg) {
          cfg_root_path = optarg;
        }
        break;
      case TEMPL_PATH:
        if (optarg) {
          template_path = optarg;
        }
        break;
      case VIF_NAME:
        if (optarg) {
          vif_name = optarg;
        }
        break;
      case DHCP_CMD:
        if (optarg) {
          dhcp_req = optarg;
          is_dhcp_cmd = true;
        }
        break;
      case SET_MAC_CMD:
        if (optarg) {
          mac = optarg;
          is_mac_cmd = true;
        }
        break;
      case ADDR_COMMIT_CMD:
        if (optarg) {
          is_addr_commit_cmd = true;
          addrs.push_back(optarg);
          for (; optind < argc && argv[optind] && *argv[optind] != '-'; optind ++) {
            addrs.push_back(argv[optind]);
          }
        }
        break;
      case CHECK_CMD:
        if (optarg) {
          type = optarg;
          is_check_cmd = true;
        }
        break;
      case CHECK_NON_SWITCHED_CMD:
        is_check_non_switched_cmd = true;
        break;
      case SHOW_CMD:
        if (optarg) {
          type = optarg;
          is_show_cmd = true;
        }
        break;
      case CHECK_BW:
        if (optarg) {
          type = optarg;
          is_check_bw = true;
        }
        break;
      case RESTORE_IPV6:
        restore_ipv6_cmd = true;
        break;
      case HAS_DHCP_ENABLED:
        has_dhcp_enabled = true;
        break;
      case SHOW_CFG_PATH:
        show_path = true;
        break;
      default:
        break;
    }
  }

  if (has_dhcp_enabled) {
    InterfaceT intf(if_name);
    if (!is_dhcp_enabled(intf)) {
      return 1;
    }
  }
  if (is_dhcp_cmd) {
    dhcp(dhcp_req, if_name);
  }
  if (is_mac_cmd) {
    update_mac(mac, if_name);
  }
  if (is_addr_commit_cmd) {
    is_valid_addr_commit(if_name, addrs);
  }
  if (is_check_cmd) {
    is_valid_name(if_name, type);
  }
  if (is_check_non_switched_cmd) {
    if (!check_non_switched(if_name)) {
      return 1;
    }
  }
  if (is_show_cmd) {
    show_interfaces(type, vif_name);
  }
  if (is_check_bw) {
    check_bw(type);
  }
  if (restore_ipv6_cmd) {
    restore_ipv6(if_name);
  }
  if (show_path) {
    show_cfg_path(if_name);
  }
  return 0;
}
